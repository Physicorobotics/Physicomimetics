<!doctype html>

<meta name="robots" content="noindex">
<html>

<head>
    <meta charset="UTF-8" />
    <title>Canvas Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/synaptic/1.1.4/synaptic.js"></script>
    <style id="jsbin-css">
        canvas {
            width: 500px;
            height: 500px;
            background-color: #95a5a6;
        }
    </style>
</head>

<body>
    <section>
        <script src="https://code.jquery.com/jquery-3.1.0.js"></script>
        <h1>Momentum: <small></small> </h1>
        <div>
            <canvas id="canvas" width="500" height="500">
        This text is displayed if your browser does not support HTML5 Canvas.
      </canvas>
        </div>

    </section>

    <h3></h3>
    <script id="jsbin-javascript">
        function randomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function randomFloat(min, max) {
            return (Math.random() * (max - min + 1)) + min;
        }


        function pythagorean(sideA, sideB) {
            return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2));
        }
        var MAXITERATION=250;
        TRAININGSETSIZE=MAXITERATION;
        var ITERATION=0;
        var DATASET=[];
        var COUNT = 5;
        var N = 2;
        var timeinterval = .0005;
        var once=true;
        var canvas;
        var ctx;var center;
        var G = 1;
        var WIDTH = 500;
        var HEIGHT = 500;
        var colors = ["#00a8ff", "#9c88ff", "#fbc531", "#4cd137", "#487eb0", "#0097e6", "#8c7ae6", "#e1b12c", "#44bd32", "#40739e", "#e84118", "#f5f6fa", "#7f8fa6", "#273c75", "#c23616", "#dcdde1", "#718093"];
        var clusters = [];
        class Mass {
            constructor(mass, x, y, cluster) {
                this.mass = mass;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.Fnet = 0;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.cluster = cluster;
                this.isStopped = false;
            }
            get whichCluster() {
                    return this.IsClustered();
                }
                // Method
            IsClustered() {
                return this.cluster;
            }

        }
        function findcenter(){
          var x=[];
          var y=[];
          for (var mass in masses) {
              var m = masses[mass];
            x[mass]=m.x;
            y[mass]=m.y;
          }
          var center1=[];
              center1[0]=average(x);
              center1[1]=average(y);
            center=center1;
             DATASET[ITERATION]={masses:masses,N:N,G:G,COUNT:COUNT,TIME:0,center:center};
        }
        class Cluster {
            constructor(x, y) {

                this.mass = mass;
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.masses = [];
            }
        }
        var masses = []; // Creates an Array of Masses
        var uniquemasses = masses;
        for (var i = 0; i < COUNT; i++) {
            masses[i] = new Mass(randomNumber(1, 30), 250 + randomNumber(-250, 250), 250 + randomNumber(-250, 250), i);
            clusters[i] = [i];
        }
        findcenter();

        function average(elmt) {
            var sum = 0;
            for (var i = 0; i < elmt.length; i++) {
                sum += parseInt(elmt[i], 10); //don't forget to add the base
            }

            var avg = sum / elmt.length;
            return avg;
        };

        var clusterNumber = 789789;
        var timestop = false;
        var time = 0;
        var buzzed = false;

        function countStopped() {
            var count = 0;
            for (var mass in masses) {
                var m = masses[mass];
                if (m.isStopped) {
                    count++;
                }
            }
            return count;
        }

        function allStopped() {
            var count = 0;
            for (var mass in masses) {
                var m = masses[mass];
                if (!m.isStopped) {
                    count++;
                }
            }
            if (count == 0) {
                return true
            } else {
                return false
            }
        }

        function IsClustered() {
            var distances = [];
            var is = false;
            var total = [0, 0];
            for (var mass in masses) {
                var m = masses[mass];
                var distance = [center[0] - m.x, center[1] - m.y];

                var d = pythagorean(distance[0], distance[1]);
                distances[mass] = d;

                for (var mass2 in masses) {
                    var m2 = masses[mass2];
                    var distance6 = [m2.x - m.x, m2.y - m.y];

                    var d6 = pythagorean(distance6[0], distance6[1]);
                    distances[mass] = d;
                    if (d6 < 20 && m2.isStopped) {
                        masses[mass].isStopped = true;

                    }
                }
                if (d < 20 && countStopped() == 0) {
                    masses[mass].isStopped = true;
                    masses[mass].vx = 0;
                    masses[mass].vy = 0;
                }
            }
            if (allStopped()) {
                is = true;
            }

            return is;
        }

        function stopAll() {

            for (var mass in masses) {
                var m = masses[mass];
                m.vx = 0;
                m.vy = 0;
            }

            timestop = true;
        };



        function applyGravity() {

            clear(); // Resets the Screen and Redraws the background

            var forces = [];


            for (var mass in masses) {
                if (!masses[mass].isStopped) {
                    var m = masses[mass];
                    var Fx = 0;
                    var Fy = 0;
                    for (var othermass in masses) {
                        var om = masses[othermass];
                        if (othermass != mass) {

                            var xr = om.x - m.x;
                            var yr = om.y - m.y;
                            var fx = (G * m.mass * om.mass * Math.pow(Math.abs(xr), N));
                            var fy = (G * m.mass * om.mass * Math.pow(Math.abs(yr), N));

                            if (xr > 0) {
                                Fx += fx;
                            } else {
                                Fx -= fx;
                            }
                            if (yr > 0) {

                                Fy += fy;

                            } else {

                                Fy -= fy;

                            }

                        }
                    }
                    var ax = Fx / m.mass;
                    var ay = Fy / m.mass;
                    forces[mass] = [ax, ay];

                } else {
                    forces[mass] = [0, 0];
                    var m = masses[mass];
                    ctx.fillStyle = m.color;
                    circle(m.x, m.y, 10);
                }
            }

            for (var mass in forces) {

                var m = masses[mass];



                if (!masses[mass].isStopped) {
                    var ax = forces[mass][0];
                    var ay = forces[mass][1];
                    m.vx = m.vx + ax;
                    m.vy = m.vy + ay;
                    if (m.y > 500 && m.vy > 0) {
                        m.vy = -m.vy;
                    } else if (m.x > 500 && m.vx > 0) {
                        m.vx = -m.vx;
                    } else if (m.y < 0 && m.vy < 0) {
                        m.vy = -m.vy;

                    } else if (m.x < 0 && m.vx < 0) {

                        m.vx = -m.vx;

                    }
                    ctx.fillStyle = m.color;
                    m.x = m.x + (timeinterval / 1000) * m.vx/ 1000;
                    m.y = m.y + (timeinterval / 1000) * m.vy/ 1000
                    if(isNaN(m.vx)||isNaN(m.vy)){DATASET[INTERVAL]=null;stopAll();}
                    circle(m.x, m.y, 10);
                }
            }






        }


        function circle(x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, true);
            ctx.fill();
        }

        function rect(x, y, w, h) {
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }


        function clear() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = "#95a5a6";
            rect(0, 0, WIDTH, HEIGHT);
        }

       function init() {
            canvas = document.getElementById("canvas");
            ctx = canvas.getContext("2d");


            return setInterval(draw, timeinterval);
        }


        function draw() {

            if (IsClustered()) {
                stopAll();
                // console.log(IsClustered());
            } else {
                applyGravity();
            }


            if (!timestop) {
                time += timeinterval;
                $("h3").text(time);

            }
            else{  ITERATION++;

               if(ITERATION<TRAININGSETSIZE+1){
            DATASET[ITERATION-1].time=time;
            console.log(DATASET[ITERATION-1]);}
              if(ITERATION<TRAININGSETSIZE){

  time = 0;
  G=randomNumber(1,50);
                COUNT = randomNumber(2, 30);
                 N = randomFloat(-2, 2);
                $("h1").text((ITERATION+1)+"/"+TRAININGSETSIZE);
               masses = []; // Creates an Array of Masses
               uniquemasses = masses;

               R = randomNumber(50, 250);
               for (var i = 0; i < COUNT; i++) {
                   masses[i] = new Mass(randomNumber(1, 30), 250 + randomNumber(-250, 250), 250 + randomNumber(-250, 250), i);
                   clusters[i] = [i];
               }
                    timestop = false;
                     findcenter();
                              clearInterval(theLoop);
                          theLoop=init();
              }

              else{
                if (once) {
                    once = false;
                    myData = JSON.stringify(DATASET);
                    var date = new Date();
                    var t = date.getTime();
                    var hiddenElement = document.createElement('a');

                    hiddenElement.href = 'data:attachment/text,' + encodeURI(myData);
                    hiddenElement.target = '_blank';
                    hiddenElement.download = 'data_' + t + '.txt';
                    hiddenElement.click();
                }
              }}
        }

        var theLoop=  init();
    </script>
</body>

</html>



<!--Once Clustered they will (hopefully) stick ¯\_(ツ)_/¯-->
